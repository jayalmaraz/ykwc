---
meta:
  title: Supabase Magic Link Auth in Remix
  description: Supabase Magic Link Auth in Remix
  date: 2022-11-20T08:00:00Z
headers:
  Cache-Control: no-cache
---

import { PostLayout } from '~/components/PostLayout';

<PostLayout
title={meta.title}
date={meta.date}
src="https://images.unsplash.com/photo-1668259678563-95f9a18e2323?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=987&q=80"
photoByName="Mak"
photoByUrl="https://unsplash.com/@mak_jp?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText"
photoOnName="Unsplash"
photoOnUrl="https://unsplash.com/explore?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText"

>

I recently started using [Remix](https://remix.run/). I've started using Remix in a few side projects. I used Remix to build this blog. I've loved every minute so far. Something that I got stuck on, when working on a different project, was using [Supabase's Magic Link](https://supabase.com/docs/reference/javascript/auth-signinwithotp) authentication in a fresh Remix app. Despite my best efforts, I couldn't write anything in Remix (without relying on Javascript) to that could consume the default magic link and create an authenticated Remix session. So I got to hacking.

## What's wrong with the default Supabase Magic Link?

Let's talk about the Supabase One Time Password (OTP) sign in function, `auth.signInWithOTP`. By default, passing an `email` into the function will result in Supabase to generating an email and delivering it to the given email address. The email will include a "Magic Link", which will look something like this:

```text
https://gffwplsndbpktzwpihso.supabase.co/auth/v1/verify?token=502743743a29d0422ed0c8ee97adeb6d55ae7f13af2f0684aa445c62&type=magiclink&redirect_to=http://localhost:3000
```

Let's unpack what's going on:

- `https://gffwplsndbpktzwpihso` â€“ Supabase project URL
- `/supabase.co/auth/v1/verify` â€“ path to auth service
- `token`, `type`, and `redirect_to` â€“ data for auth service

From this we can infer that the Supabase auth service is doing some work based on the `type`. It consumes the `token` to verify the link (is it valid? has it already been used? has it expired? etc.) before `redirect`ing back `to` our app with the authenticated state. Great, so why doesn't that _just work_ with a Remix app?

The problem is the "authenticated state". Supabase expects us to handle this with Javascript by using the `onAuthStateChange` listener wrapped in a `useEffect` to catch the "magic" and store the session in a `Context`. Those are a lot of Javascript concepts; not very Remix! Let's take a look at the Remix solution.

## The Remix solution

To get things running, we're going to create our own magic link. We know that we don't want to use the out-of-the box magic link because it relies on Javascript to work. But we still want the user to be able to click a "magic" link via email, and subsequently be signed up/signed in. To create our solution we need to do two things:

1. Customise the Supabase Authentication Email Templates â€“ our own magic link!
2. Implement an OTP verification handler â€“ our own little auth service!

## 1. Our own magic link (Supabase)

There are two (2) Supabase emails that are critical for sign-up/sign-in: _Confirm signup_ and _Magic Link_. Your original Supabase email templates will always include an anchor tag that features the `.ConfirmationURL` message variable, which looks something like this:

```html
<p><a href="{{ .ConfirmationURL }}">Confirm email</a></p>
```

We need to swap out the `href` and design our own URL using the individual parts of that make up the original. Our solution looks like this:

```html
<p><a href="{{ .SiteURL }}/auth/verify?email={{ .Email }}&token={{ .Token }}&type=signup">Confirm email</a></p>
```

All of the variables beginning with a `.` (`.SiteURL`, `.Email`, and `.Token`) are inserted by Supabase when the email is dispatched. Slightly different, but just as essential, the authentication type (`type=signup` or `type=magiclink`) is something that we need to hardcode in the email template. The type is used by our verification handler, later. Finally the verification path (`/auth/verify` in this example) is where we point for the actual verification to occur.

```text
   Your app URL      Our verification path           Supabase auth type
         /             /                                          \
        /             /                                            \
       v             v                                              v
{{ .SiteURL }}/auth/verify?email={{ .Email }}&token={{ .Token }}&type=signup
                                      ^                   ^
                                     /                   /
                                    /                   /
                              User's email         Supabase token
```

If we take our customised link and insert it into the _Confirm signup_ Email Template:

```html
<h2>Confirm your signup</h2>

<p>Follow this link to confirm your user:</p>
<p><a href="{{ .SiteURL }}/auth/verify?email={{ .Email }}&token={{ .Token }}&type=signup">Confirm email</a></p>
```

And then similarly into the _Magic Link_ Email Template:

```html
<h2>Magic Link</h2>

<p>Follow this link to login:</p>
<p><a href="{{ .SiteURL }}/auth/verify?email={{ .Email }}&token={{ .Token }}&type=magiclink">Confirm email</a></p>
```

With the custom email templates done, all that's left is to write our own small authentication flow in Remix.

## 1. Our own little auth service (Remix)

Our authentication system is _very_ standard. 80% of the code in this example is just boilerplate Remix. In terms of routes, we'll need a simple sign in page, and then a profile page to show when we're signed in. The 'magic link' side of things is handled by a verification route, which we direct the user to via our custom link. We also have a basic confirmation message page to tell the user to go and check their email after signing in. Everything is then wrapped up in a stock standard Remix authentication session, which uses the Supabase client to call the sign in and verify functions.

```text
app
â”œâ”€â”€ entry.client.tsx
â”œâ”€â”€ entry.server.tsx
â”œâ”€â”€ root.tsx
â”œâ”€â”€ routes
â”‚    â”œâ”€â”€ auth
â”‚    â”‚    â”œâ”€â”€ ðŸ“„ confirm.tsx
â”‚    â”‚    â””â”€â”€ ðŸ“„ verify.tsx
â”‚    â”œâ”€â”€ ðŸ“„ profile.tsx
â”‚    â””â”€â”€ ðŸ“„ index.tsx
â””â”€â”€ utils
     â”œâ”€â”€ ðŸ“„ session.server.ts
     â””â”€â”€ ðŸ“„ supabase.server.ts
```

Let's go through the code snippets for each file needed for the magic link verification to work. These are _NOT_ the complete files, only the important parts are included. It's assumed that you already have experience working with Remix, that you understand the basics of using `loader` and `action` functions, and that you're familiar with session authentication in Remix using cookies.

> The full example repo can be found [here](https://github.com/jayalmaraz) !TODO: LINK TO GITHUB REPOSITORY CONTAINING EXAMPLE PROJECT

First get your server side utilities setup.

```ts showLineNumbers title="app/utils/supabase.server.ts"
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  // get these from your Supabase project and add them to your .env file
  process.env.PUBLIC_SUPABASE_URL!,
  process.env.PUBLIC_SUPABASE_ANON_KEY!
);

export default supabase;
```

```ts showLineNumbers title="app/utils/session.server.ts (snippet âœ‚ï¸)"
import type { EmailOtpType } from '@supabase/supabase-js';
import supabase from './supabase';

type LoginForm = {
  email: string;
};

async function login({ email }: LoginForm) {
  const { data, error } = await supabase.auth.signInWithOtp({ email });
  if (!data || error) {
    return null;
  }
  return data;
}

type VerifyParams = {
  email: string;
  token: string;
  type: EmailOtpType;
};

async function verify({ email, type, token }: VerifyParams) {
  const { data, error } = await supabase.auth.verifyOtp({ email, type, token });
  const userId = data.user?.id;
  if (error || !userId || typeof userId !== 'string') {
    return null;
  }
  return userId;
}

// ...

export { login, verify };
```

Then create a basic sign in form to take an email address as input, and call the `signInWithOtp` function in the submit action:

```ts showLineNumbers title="app/routes/index.tsx (snippet âœ‚ï¸)"
import type { ActionFunction } from '@remix-run/node';
import { json, redirect } from '@remix-run/node';
import { login } from '~/utils/session.server';

export const action: ActionFunction = async ({ request }) => {
  // get the email value from the sign in form
  const formData = await request.formData();
  const email = formData.get('email');

  if (!email || typeof email !== 'string') {
    return json({ error: 'Form error ðŸ’©' });
  }

  // sign in with email
  const data = await login({ email });

  if (!data) {
    return json({ error: 'Supabase error ðŸ’©' });
  }

  // redirect to "check your email" screen
  return redirect('/auth/confirm');
};

// ...
```

Next you'll want a really simple, completely static, message screen to direct the user to if the sign in form submits successfully:

```ts showLineNumbers title="app/routes/auth/confirm.tsx"
export default function ConfirmPage() {
  return (
    <div>
      <h1>Supabase Magic Link x Remix</h1>
      <p>Check your email for a verification link</p>
    </div>
  );
}
```

And now the fun part. This is our "magic" verification page, where we direct the user when they click on the link in the email. This page grabs the info from the URL params (which we already set in the Supabase email templates) and calls the Supabase `verifyOtp` function. If the verification is successful we create a session:

```ts showLineNumbers title="app/routes/auth/verify.tsx (snippet âœ‚ï¸)"
import type { LoaderFunction } from '@remix-run/node';
import { json } from '@remix-run/node';
import invariant from 'tiny-invariant';
import { createUserSession, verify } from '~/utils/session.server';

function getUrlParams(url: string) {
  const urlObject = new URL(url);
  const email = urlObject.searchParams.get('email');
  const token = urlObject.searchParams.get('token');

  // ensure that type is present and a correct value
  const type: 'signup' | 'magiclink' | null = urlObject.searchParams.get('type') as any;
  invariant(type, 'Invalid type'); // We use tiny-invariant to make type narrowing easier

  // ensure that email and token are present
  if (typeof email !== 'string' || typeof token !== 'string') {
    throw new Error('Bad params');
  }

  return { email, token, type };
}

export const loader: LoaderFunction = async ({ request }) => {
  try {
    // get magic link information from URL
    const { email, token, type } = getUrlParams(request.url);

    // verify magic link
    const userId = await verify({ email, token, type });
    if (!userId) {
      throw new Error('Authentication failed');
    }

    // create session from resulting user ID
    return createUserSession(userId, '/profile');
  } catch (e: any) {
    return json({ error: 'Unable to verify magic link ðŸ’©' });
  }
};

// ...
```

For housekeeping, here is an example of a basic profile page so that you can see the user ID attached to the session. It also provides a simple logout action to clear the session:

```ts showLineNumbers title="app/routes/profile.tsx"
import type { ActionFunction, LoaderFunction } from '@remix-run/node';
import { json } from '@remix-run/node';
import { Form, useLoaderData } from '@remix-run/react';
import { logout, requireUserId } from '~/utils/session.server';

// this should be a separate route so that it can be reused
export const action: ActionFunction = async ({ request }) => {
  return logout(request);
};

export const loader: LoaderFunction = async ({ request }) => {
  // this handles the redirect-on-fail for us
  const userId = await requireUserId(request);
  return json({ userId });
};

export default function ProfilePage() {
  const { userId } = useLoaderData();

  return (
    <div>
      <h1>Supabase Magic Link x Remix</h1>
      <p>You're signed in with user ID: {userId}</p>

      <Form method="post">
        <button>Logout</button>
      </Form>
    </div>
  );
}
```

```text












```

x

````

## Aside: Relying on Javascript

While writing this blog, I searched around one last time to double-check for more elegant solutions than mine. I came across [a discussion](https://github.com/supabase/supabase/discussions/3762) where someone links to an example repo that is functional â€“ it works with Supabase Magic Links. Unfortunately that solution relies entirely on a React Context, which is okay, but means that the it doesn't work without Javascript. We can do better.

To get our version working, we need to stretch the Supabase Magic Link feature a little bit. The trick is moving away from the strictly email-based magic link, and instead leaning on the generic One Time Password system that Supabase uses under the hood â€“ similar to how their SMS verification code would work. We just need to send our own magic verification code.

---

```ts
type: 'signup' | 'invite' | 'magiclink' | 'email_change' | 'recovery' | 'sms' | 'phone_change';
````

```
   what to do (delete, change...)
      /
     /      how many times
    /         /
   v         v
{operator}{count}{motion}
                    ^
                   /
                  /
           where to perform
             the action
```

### Authentication Verification Handler

The very first time that `signInWithOTP` is called for a given email, the link will actually include `type=signup`. This is to inform the Supabase auth handler that it needs to verify the link, create

```
https://gffwplsnddpktzwpihso.supabase.co/auth/v1/verify?token=502743743a29d0422ed0c8ee97adeb6d55ae7f13af2f0684aa445c62&type=signup&redirect_to=http://localhost:3000
```

Confirm signup

```
{{ .SiteURL }}/auth/verify?email={{ .Email }}&token={{ .Token }}&type=signup
```

Magic Link

```
{{ .SiteURL }}/verify?email={{ .Email }}&token={{ .Token }}&type=magiclink
```

```js
// TODO: Fix MDX to make all MD links open in new tab
// TODO: Analytics
// TODO: Link to my twitter
// TODO: Investigate the GitHub discussion and see if there is actually a straight forward working version now...
// TODO: Remove ~/ paths from imports (i.e. make no assumption about tsconfig)
```

- Full disclaimer, the working version of this is more of a workaround
- Subject to brittleness and becoming out of date as it doesn't strictly use the built in Supabase magic link system

## Configuring Supabase

- More broadly known as: One Time Password (OTP) authentication
- It looks something like this by default: `https://{{...}}.supabase.co/auth/v1/verify?token={{...}}&type=magiclink&redirect_to=http://localhost:3000`
- It does this behind the scenes: ...
- But it doesn't play nicely with Remix. As outlined in [this clumsy discussion](https://github.com/supabase/supabase/discussions/3762), Supabase auth won't really be humming unless you force it to with some dank ass hooks (see the `useUser` hook). The [example repo](https://github.com/VictorPeralta/supabase-remix-auth/blob/main/app/routes/index.tsx) that dude links to uses tons of Javascript in general, and we ain't 'bout that.
- BUT, Supabase can give you the information required to do a password-less sign is
- UX is identical to the vanilla magic link
- Here is how to set it up on the Supabase side: ...

## Creating the Remix auth session

- Then it's just a standard Remix auth session
- Here is how to set it up in Remix: ...

## Appendix

Supabase Confirm signup email template

```html

```

Supabase Magic Link email template

```html

```

</PostLayout>
